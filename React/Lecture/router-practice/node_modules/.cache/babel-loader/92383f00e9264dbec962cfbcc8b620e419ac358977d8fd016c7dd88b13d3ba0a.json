{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\nvar React = require('react');\nvar React__default = _interopDefault(React);\nvar reactRouterDom = require('react-router-dom');\nfunction _regeneratorRuntime() {\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n\n  _regeneratorRuntime = function () {\n    return exports;\n  };\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return generator._invoke = function (innerFn, self, context) {\n      var state = \"suspendedStart\";\n      return function (method, arg) {\n        if (\"executing\" === state) throw new Error(\"Generator is already running\");\n        if (\"completed\" === state) {\n          if (\"throw\" === method) throw arg;\n          return doneResult();\n        }\n        for (context.method = method, context.arg = arg;;) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n          if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n            if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n            context.dispatchException(context.arg);\n          } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n          state = \"executing\";\n          var record = tryCatch(innerFn, self, context);\n          if (\"normal\" === record.type) {\n            if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          }\n          \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n        }\n      };\n    }(innerFn, self, context), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    this._invoke = function (method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n      return ContinueSentinel;\n    }\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (object) {\n    var keys = [];\n    for (var key in object) keys.push(key);\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n    },\n    stop: function () {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    catch: function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction useBlocker(blocker, when) {\n  if (when === void 0) {\n    when = true;\n  }\n  var _useContext = React.useContext(reactRouterDom.UNSAFE_NavigationContext),\n    navigator = _useContext.navigator;\n  React.useEffect(function () {\n    if (!when) return; // @ts-ignore\n\n    var unblock = navigator.block(function (tx) {\n      var autoUnblockingTx = _extends({}, tx, {\n        retry: function retry() {\n          // Automatically unblock the transition so it can play all the way\n          // through before retrying it. TODO: Figure out how to re-enable\n          // this block if the transition is cancelled for some reason.\n          unblock();\n          tx.retry();\n        }\n      });\n      blocker(autoUnblockingTx);\n    });\n    return unblock;\n  }, [navigator, blocker, when]);\n}\nvar ConfirmContext = /*#__PURE__*/React__default.createContext(null);\nvar ConfirmContextProvider = function ConfirmContextProvider(_ref) {\n  var children = _ref.children;\n  var _useState = React.useState(false),\n    resolve = _useState[0],\n    setResolve = _useState[1];\n  return React__default.createElement(ConfirmContext.Provider, {\n    value: {\n      resolve: resolve,\n      setResolve: setResolve\n    }\n  }, children);\n};\nvar noop = function noop() {\n  /*No Operation*/\n};\nvar initialConfirmState = {\n  isActive: false,\n  proceed: noop,\n  cancel: noop\n};\nvar useConfirm = function useConfirm(when) {\n  var _useState = React.useState(initialConfirmState),\n    confirm = _useState[0],\n    setConfirm = _useState[1];\n  var _ref = React.useContext(ConfirmContext) || {},\n    setResolve = _ref.setResolve;\n  React.useEffect(function () {\n    if (confirm.isActive) {\n      window.onbeforeunload = function () {\n        return false;\n      };\n    }\n    return function () {\n      if (confirm.isActive) window.onbeforeunload = null;\n    };\n  }, [confirm]);\n  var resetConfirmation = React.useCallback(function () {\n    setConfirm(initialConfirmState);\n  }, []);\n  var onConfirm = React.useCallback( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tx) {\n      var promise;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              promise = new Promise( /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {\n                  var shouldPrompt;\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          setConfirm(function (prevState) {\n                            return _extends({}, prevState, {\n                              isActive: true,\n                              proceed: resolve,\n                              cancel: reject\n                            });\n                          }); // Go ahead and resolve the promise when the `when` function\n                          // returns `false`, which means the prompt should not be displayed\n                          // and navigation should occur.\n\n                          if (!(typeof when === \"function\")) {\n                            _context.next = 6;\n                            break;\n                          }\n                          _context.next = 4;\n                          return when(tx.location, tx.action);\n                        case 4:\n                          shouldPrompt = _context.sent;\n                          if (!shouldPrompt) {\n                            resolve(true);\n                          }\n                        case 6:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n                return function (_x2, _x3) {\n                  return _ref3.apply(this, arguments);\n                };\n              }());\n              return _context2.abrupt(\"return\", promise.then(function () {\n                setResolve == null ? void 0 : setResolve(true);\n                setConfirm(_extends({}, confirm, {\n                  isActive: false\n                }));\n                return true;\n              }, function () {\n                setConfirm(_extends({}, confirm, {\n                  isActive: false\n                }));\n                setResolve == null ? void 0 : setResolve(false);\n                return false;\n              }));\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return function (_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }(), [confirm, setResolve, when]);\n  return _extends({}, confirm, {\n    onConfirm: onConfirm,\n    resetConfirmation: resetConfirmation\n  });\n};\n\n/**\r\n * A replacement component for the react-router `Prompt`.\r\n * Allows for more flexible dialogs.\r\n *\r\n * @example\r\n * <ReactRouterPrompt when={isDirty}>\r\n *   {({isActive, onConfirm, onCancel}) => (\r\n *     <Modal show={isActive}>\r\n *       <div>\r\n *         <p>Do you really want to leave?</p>\r\n *         <button onClick={onCancel}>Cancel</button>\r\n *         <button onClick={onConfirm}>Ok</button>\r\n *       </div>\r\n *     </Modal>\r\n *   )}\r\n * </ReactRouterPrompt>\r\n */\n\nvar ReactRouterPrompt = function ReactRouterPrompt(_ref) {\n  var when = _ref.when,\n    children = _ref.children;\n  var _useConfirm = useConfirm(when),\n    onConfirm = _useConfirm.onConfirm,\n    resetConfirmation = _useConfirm.resetConfirmation,\n    isActive = _useConfirm.isActive,\n    proceed = _useConfirm.proceed,\n    cancel = _useConfirm.cancel;\n  var _ref2 = React.useContext(ConfirmContext) || {},\n    resolve = _ref2.resolve;\n  var blocker = React.useCallback( /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tx) {\n      var result;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return onConfirm(tx);\n            case 2:\n              result = _context.sent;\n              if (result) {\n                resetConfirmation();\n                tx.retry();\n              }\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return function (_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [resetConfirmation, onConfirm]); // TODO: Check fif effect is required to reset resolution if \"when\" is changed.\n\n  useBlocker(blocker, when && !resolve);\n  return React__default.createElement(\"div\", null, children({\n    isActive: isActive,\n    onConfirm: proceed,\n    onCancel: cancel\n  }));\n};\nvar Main = function Main(props) {\n  return React__default.createElement(ConfirmContextProvider, null, React__default.createElement(ReactRouterPrompt, Object.assign({}, props)));\n};\nexports.default = Main;","map":{"version":3,"mappings":"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","names":["useBlocker","blocker","when","useContext","NavigationContext","navigator","useEffect","unblock","block","tx","autoUnblockingTx","retry","ConfirmContext","React","createContext","ConfirmContextProvider","children","useState","resolve","setResolve","Provider","value","noop","initialConfirmState","isActive","proceed","cancel","useConfirm","confirm","setConfirm","window","onbeforeunload","resetConfirmation","useCallback","onConfirm","promise","Promise","reject","prevState","_context","location","action","shouldPrompt","then","ReactRouterPrompt","result","onCancel","Main","props"],"sources":["/Users/gimseungheon/Documents/front_project/React/Lecture/router-practice/node_modules/react-router-prompt/src/hooks/use-blocker.ts","/Users/gimseungheon/Documents/front_project/React/Lecture/router-practice/node_modules/react-router-prompt/src/ConfirmContext.tsx","/Users/gimseungheon/Documents/front_project/React/Lecture/router-practice/node_modules/react-router-prompt/src/hooks/use-confirm.ts","/Users/gimseungheon/Documents/front_project/React/Lecture/router-practice/node_modules/react-router-prompt/src/index.tsx"],"sourcesContent":["import { useContext, useEffect } from \"react\";\nimport { Blocker, Transition } from \"history\";\n// @ts-ignore\nimport { UNSAFE_NavigationContext as NavigationContext } from \"react-router-dom\";\n\nfunction useBlocker(blocker: Blocker, when = true) {\n  const { navigator } = useContext(NavigationContext);\n\n  useEffect(() => {\n    if (!when) return;\n\n    // @ts-ignore\n    const unblock = navigator.block((tx: Transition) => {\n      const autoUnblockingTx = {\n        ...tx,\n        retry() {\n          // Automatically unblock the transition so it can play all the way\n          // through before retrying it. TODO: Figure out how to re-enable\n          // this block if the transition is cancelled for some reason.\n          unblock();\n          tx.retry();\n        },\n      };\n\n      blocker(autoUnblockingTx);\n    });\n\n    return unblock;\n  }, [navigator, blocker, when]);\n}\n\nexport default useBlocker;\n","import React, { useState } from \"react\";\n\ninterface ContextProviderType {\n  resolve?: boolean;\n  setResolve?: (value: boolean) => void;\n}\n\nexport const ConfirmContext = React.createContext<ContextProviderType | null>(\n  null\n);\n\nconst ConfirmContextProvider: React.FC<{ children: React.ReactNode }> = ({\n  children,\n}) => {\n  const [resolve, setResolve] = useState(false);\n\n  return (\n    <ConfirmContext.Provider\n      value={{\n        resolve,\n        setResolve,\n      }}\n    >\n      {children}\n    </ConfirmContext.Provider>\n  );\n};\n\nexport default ConfirmContextProvider;\n","import { useState, useEffect, useCallback, useContext } from \"react\";\nimport { ConfirmContext } from \"../ConfirmContext\";\nimport { Transition } from \"history\";\nimport { ReactRouterPromptProps } from \"..\";\n\nconst noop = () => {\n  /*No Operation*/\n};\n\nconst initialConfirmState = {\n  isActive: false,\n  proceed: noop,\n  cancel: noop,\n};\n\ndeclare interface InitialStateType {\n  isActive: boolean;\n  proceed: (value: unknown) => void;\n  cancel: (value: unknown) => void;\n}\n\ndeclare interface ConfirmLeaveReturnType extends InitialStateType {\n  onConfirm: (tx: Transition) => Promise<boolean>;\n  resetConfirmation: () => void;\n}\n\nconst useConfirm = (\n  when: ReactRouterPromptProps[\"when\"]\n): ConfirmLeaveReturnType => {\n  const [confirm, setConfirm] = useState<InitialStateType>(initialConfirmState);\n  const { setResolve } = useContext(ConfirmContext) || {};\n\n  useEffect(() => {\n    if (confirm.isActive) {\n      window.onbeforeunload = (): boolean => {\n        return false;\n      };\n    }\n\n    return (): void => {\n      if (confirm.isActive) window.onbeforeunload = null;\n    };\n  }, [confirm]);\n\n  const resetConfirmation = useCallback(() => {\n    setConfirm(initialConfirmState);\n  }, []);\n\n  const onConfirm = useCallback(\n    async (tx: Transition): Promise<boolean> => {\n      const promise = new Promise(async (resolve, reject) => {\n        setConfirm((prevState: InitialStateType) => ({\n          ...prevState,\n          isActive: true,\n          proceed: resolve,\n          cancel: reject,\n        }));\n\n        // Go ahead and resolve the promise when the `when` function\n        // returns `false`, which means the prompt should not be displayed\n        // and navigation should occur.\n        if (typeof when === \"function\") {\n          const shouldPrompt = await when(tx.location, tx.action);\n          if (!shouldPrompt) {\n            resolve(true);\n          }\n        }\n      });\n\n      return promise.then(\n        () => {\n          setResolve?.(true);\n          setConfirm({ ...confirm, isActive: false });\n          return true;\n        },\n        () => {\n          setConfirm({ ...confirm, isActive: false });\n          setResolve?.(false);\n          return false;\n        }\n      );\n    },\n    [confirm, setResolve, when]\n  );\n\n  return {\n    ...confirm,\n    onConfirm,\n    resetConfirmation,\n  };\n};\n\nexport default useConfirm;\n","import React, { useCallback, useContext } from \"react\";\nimport { Action, Location, Transition } from \"history\";\n\nimport useBlocker from \"./hooks/use-blocker\";\nimport ConfirmContextProvider, { ConfirmContext } from \"./ConfirmContext\";\nimport useConfirm from \"./hooks/use-confirm\";\n\nexport type ReactRouterPromptProps = {\n  when: boolean | ((nextLocation: Location, _action: Action) => boolean);\n  children: (data: {\n    isActive: boolean;\n    onCancel: (value: unknown) => void;\n    onConfirm: (value: unknown) => void;\n  }) => React.ReactNode;\n};\n\n/**\n * A replacement component for the react-router `Prompt`.\n * Allows for more flexible dialogs.\n *\n * @example\n * <ReactRouterPrompt when={isDirty}>\n *   {({isActive, onConfirm, onCancel}) => (\n *     <Modal show={isActive}>\n *       <div>\n *         <p>Do you really want to leave?</p>\n *         <button onClick={onCancel}>Cancel</button>\n *         <button onClick={onConfirm}>Ok</button>\n *       </div>\n *     </Modal>\n *   )}\n * </ReactRouterPrompt>\n */\n\nconst ReactRouterPrompt: React.FC<ReactRouterPromptProps> = ({\n  when,\n  children,\n}) => {\n  const {\n    onConfirm,\n    resetConfirmation,\n    isActive,\n    proceed,\n    cancel,\n  } = useConfirm(when);\n  const { resolve } = useContext(ConfirmContext) || {};\n\n  const blocker = useCallback(\n    async (tx: Transition) => {\n      const result = await onConfirm(tx);\n      if (result) {\n        resetConfirmation();\n        tx.retry();\n      }\n    },\n    [resetConfirmation, onConfirm]\n  );\n\n  // TODO: Check fif effect is required to reset resolution if \"when\" is changed.\n\n  useBlocker(blocker, when && !resolve);\n\n  return (\n    <div>\n      {children({\n        isActive,\n        onConfirm: proceed,\n        onCancel: cancel,\n      })}\n    </div>\n  );\n};\n\nconst Main: React.FC<ReactRouterPromptProps> = props => {\n  return (\n    <ConfirmContextProvider>\n      <ReactRouterPrompt {...props} />\n    </ConfirmContextProvider>\n  );\n};\n\nexport default Main;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}